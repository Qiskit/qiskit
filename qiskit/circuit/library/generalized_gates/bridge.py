# This code is part of Qiskit.
#
# (C) Copyright IBM 2017, 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""bridge gate."""
from qiskit.circuit.quantumcircuit import QuantumCircuit
from qiskit.circuit.quantumregister import QuantumRegister
from qiskit.exceptions import QiskitError


class BridgeGate(QuantumCircuit):
    r"""Global bridge gate.

    *For n = 3

    In [1], the definition of the bridge gate is given and the gate is composed
    of 4 CNOTs gates.

    [1] Toshinari et al.(2019), https://arxiv.org/pdf/1907.02686.pdf

    **Circuit symbol:**

    .. parsed-literal::

         ┌─────────┐
    q_0: ┤0        ├
         │         │
    q_1: ┤1 bridge ├
         │         │
    q_2: ┤2        ├
         └─────────┘

         ┌───┐                q_0: ──■─────────■───────
    q_0: ┤ X ├                     ┌─┴─┐     ┌─┴─┐
         └─┬─┘                q_1: ┤ X ├──■──┤ X ├──■──
    q_1: ──┼──       =             └───┘┌─┴─┐└───┘┌─┴─┐
           │                  q_2: ─────┤ X ├─────┤ X ├
    q_2: ──■──                          └───┘     └───┘


    **Matrix Representation:**

    .. math::
        \begin{bmatrix}
            1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
            0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\
            0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\
            0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\
            0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\
            0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\
            0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\
            0 & 0 & 0 & 1 & 0 & 0 & 0 & 0
        \end{bmatrix}


    *For n > 3

    We exploit the definition of group generated by the CNOT gates in [2] page 6.


    **Matrix representation:**

    The bridge gate a (represented by) matrices of size $2^n × 2^n$ in the
    orthogonal group $O_{2^n}(R)$ and that they are permutation matrices.


    **Example:**

    For n = 4

    It is demonstrated in [2] that for n=4 the circuit can be CX-BRIDGE-CX-BRIDGE or BRIDGE-CX-BRIDGE-CX

         ┌───┐                   ┌───┐     ┌───┐             ┌───┐     ┌───┐
    q_0: ┤ X ├         q_0: ─────┤ X ├─────┤ X ├        q_0: ┤ X ├─────┤ X ├─────
         └─┬─┘                   └─┬─┘     └─┬─┘             └─┬─┘     └─┬─┘
    q_1: ──┼──         q_1: ───────┼─────────┼──        q_1: ──┼─────────┼───────
           │       =        ┌───┐  │  ┌───┐  │     =           │  ┌───┐  │  ┌───┐
    q_2: ──┼──         q_2: ┤ X ├──■──┤ X ├──■──        q_2: ──■──┤ X ├──■──┤ X ├
           │                └─┬─┘     └─┬─┘                       └─┬─┘     └─┬─┘
    q_3: ──■──         q_3: ──■─────────■───────        q_3: ───────■─────────■──

                            CX-BRIDGE-CX-BRIDGE             BRIDGE-CX-BRIDGE-CX



    [2] Marc Bataille (2020), https://hal-normandie-univ.archives-ouvertes.fr/hal-02948598/document


    ..Note::

        The bridge gate is used as a transformation rule in mapping.
    """

    def __init__(self, num_qubits: int):
        """Create new bridge gate.
        Depending on the number of qubits n, this creates an
        explicit BridgeGate instance for n > 2.
        """

        if num_qubits < 3:
            raise QiskitError(
                "BridgeGate is only defined with num_qubits > 2, "
                f"provided num_qubits = {num_qubits}."
            )

        super().__init__(
            num_qubits,
            name="bridge",
        )

        qr = QuantumRegister(self.num_qubits, "q")
        bridge = QuantumCircuit(qr, name=self.name)

        for i in range(num_qubits - 1):

            for j in range(num_qubits - 1):
                j = i + 1
            bridge.cx(i, j)

        for i in range(num_qubits - 3, 0, -1):

            for j in range(num_qubits - 3, 0, -1):
                j = i + 1
            bridge.cx(i, j)

        for i in range(num_qubits - 1):

            for j in range(num_qubits - 1):
                j = i + 1
            bridge.cx(i, j)

        for i in range(num_qubits - 3, 0, -1):

            for j in range(num_qubits - 3, 0, -1):
                j = i + 1
            bridge.cx(i, j)

        self.append(bridge, self.qubits)
