---
features:
  - |
    Introduced a C API to build and interact with sparse observables.
    This API does not yet allow for an end-to-end workflow in C, but rather lays the 
    foundation for Qiskit's C interface. The (dynamic) C library is compiled by Rust and 
    the header file can be automatically generated using ``cbindgen``, both of which is 
    done by running ``make cheader``.

    The detailed syntax and more information is available under the C API docs, 
    but a minimal example to construct the 100-qubit observable ``X0 Y1 Z1`` is:

    .. code:: c

      #include <stdio.h>
      #include "qiskit.h"

      int main() {
        // build a 100-qubit empty observable
        u_int32_t num_qubits = 100;
        QkSparseObservable *obs = qk_obs_zero(num_qubits);  

        // add the term 2 * (X0 Y1 Z2) to the observable
        complex double coeff = 2;  // the coefficient
        QkBitTerm bit_terms[3] = {QkBitTerm_X, QkBitTerm_Y, QkBitTerm_Z};  // bit terms: X Y Z
        uint32_t indices[3] = {0, 1, 2};  // indices: 0 1 2
        QkSparseTerm term = {&coeff, 3, bit_terms, indices, num_qubits};
        qk_obs_add_term(obs, &term);  // append the term

        // print some properties
        printf("num_qubits: %i\n", qk_obs_num_qubits(obs));
        printf("num_terms: %i\n", qk_obs_num_terms(obs));

        // free the memory allocated for the observable
        obs_free(obs);
      
        return 0;
      }

    To compile the above, a Rust compiler is required to build the dynamic library and 
    ``cbindgen`` to build the header. Then the C script can be compiled by specifying the library's 
    location, e.g., using ``gcc``, we have:

    .. code::

      make cheader  # build's the library into ./target/release and the header into root
      gcc <my_script.c> -lqiskit_cext -L./target/release -I./  # compile and link the library
    