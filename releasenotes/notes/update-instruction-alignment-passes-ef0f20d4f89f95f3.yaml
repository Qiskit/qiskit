---
features:
  - |
    Added a new transpiler pass :class:`~.ConstrainedReschedule` pass.
    The :class:`ConstrainedReschedule` pass considers both hardware
    alignment constraints that can be definied in a :class:`.BackendConfiguration`
    object, ``pulse_alignment`` and ``acquire_alignment``. This new class superscedes
    the previosuly existing :class:`~.AlignMeasures` as it performs the same alignment
    (via the property set) for measurement instructions in addition to general instruction
    alignment. By setting the ``acquire_alignment`` constraint for
    :class:`ConstrainedReschedule` which is a drop-in replacement of
    :class:`~.AlignMeasures` when paired with a new :class:`~.BasePadding` pass.
  - |
    Added new transpiler passes :class:`~.ALAPScheduleAnalysis` and :class:`~.ASAPScheduleAnalysis`
    which superscede the :class:`~.ALAPSchedule` and :class:`~.ASAPSchedule` as part of the
    reworked transpiler workflow for schedling. The new passes perform the same scheduling but
    in the property set and relying on a :class:`~.BasePadding` pass to adjust the circuit
    based on all the scheduling alignment analysis.
  - |
    Added a  new transpiler pass :class:`~.DynamicalDecouplingPadding`
    which superscedes the :class:`~.DynamicalDecoupling` pass as part of the
    reworked transpiler workflow for scheduling. This new pass will insert dynamical decoupling
    sequences into the circuit per any scheduling and alignment analysis that occured in earlier
    passes.
  - |
    Introduced a new transpiler pass workflow for building :class:`~.PassManager` objects
    for scheduling :class:`~.QuantumCircuit` objects in the transpiler. In the new
    workflow scheduling and alignment passes are all :class:`~.AnalysisPass` objects that
    only updates the property set of the pass manager, in which new property set
    ``node_start_time`` is created there to perform these operation on nodes
    scheduled on the absolute time. This new workflow is both more efficient and can correct
    for additional timing constraints exposed by a backend.

    Previously, the pass chain would have been implemented as ``scheduling -> alignment``
    which were both transform passes thus there were multiple :class:`~.DAGCircuit`
    instances recreated during each pass. In addition, scheduling occured in each pass
    to obtain instruction start time. Now the required pass chain becomes
    ``scheduling -> alignment -> padding`` where the :class:`~.DAGCircuit` update only
    occurs at the end with the ``padding`` pass.

    For those who are creating custom :class:`~.PassManager` objects that involve
    circuit scheduling you will need to adjust your :class:`~.PassManager`
    to include insert one of the :class:`~.BasePadding` passes (currently
    either :class:`~.PadDelay` or :class:`~.DynamicalDecoupling` can be used)
    at the end of the scheduling pass chain. Without the padding pass the scheduling
    passes will not be reflected in the output circuit of the :meth:`~.PassManager.run`
    method of your custom :class:`~.PassManager`.

    For example, if you were previously building your :class:`~.PassManager`
    with something like::

        from qiskit.transpiler import PassManager
        from qiskit.transpiler.passes import TimeUnitConversion, ALAPSchedule, ValidatePulseGates, AlignMeasures

        pm = PassManager()
        scheduling = [
            ALAPSchedule(instruction_durations), PadDelay()),
            ValidatePulseGates(granularity=timing_constraints.granularity, min_length=timing_constraints.min_length),
            AlignMeasures(alignment=timing_constraints.acquire_alignment),
        ]
        pm.append(scheduling)

    you can instead use::

        from qiskit.transpiler import PassManager
        from qiskit.transpiler.passes import TimeUnitConversion, ALAPScheduleAnalysis, ValidatePulseGates, AlignMeasures, PadDelay

        pm = PassManager()
        scheduling = [
            ALAPScheduleAnalysis(instruction_durations), PadDelay()),
            InstructionDurationCheck(acquire_alignment=timing_constraints.acquire_alignment, pulse_alignment=timing_constraints.pulse_alignment),
            ConstrainedReschedule(acquire_alignment=timing_constraints.acquire_alignment, pulse_alignment=timing_constraints.pulse_alignment),
            ValidatePulseGates(granularity=timing_constraints.granularity, min_length=timing_constraints.min_length),
            PadDelay()
        ]
        pm.append(scheduling)

    which will both be more efficient and also align instructions based on any hardware constraints.
