---
features_c:
  - |
    The :ref:`C_API` now supports building a :class:`~.Target` to represent a
    transpilation target. For example:

    .. code-block:: C

      #include <qiskit.h>
      #include <math.h>

      int main() {
          // Create a Target with 3 qubits
          QkTarget *target = qk_target_new(3);

          // Create a Target Entry for a CX Gate
          QkTargetEntry *cx_entry = qk_target_entry_new(QkGate_CX);
          // Define properties for CX between qubits (0, 1) with a duration of 1.93e-9 sec and error rate 3.17e-10.
          uint32_t qargs[2] = {0, 1};
          qk_target_entry_add_property(cx_entry, qargs, 2, 1.93e-9, 3.17e-10);
          // Define properties for cx between qubits (1, 0) with a duration of 1.27e-9 sec and no error.
          uint32_t rev_qargs[2] = {1, 2};
          qk_target_entry_add_property(cx_entry, rev_qargs, 2, 1.27e-9, NAN);
          // Add the cx entry to the target.
          QkExitCode result_cx = qk_target_add_instruction(target, cx_entry);
          // Add global ideal Y gate entry to the target
          QkExitCode result_y = qk_target_add_instruction(target, qk_target_entry_new(QkGate_Y));
          // Create a Target entry for a Measurement with increasing duration and error as the qubit indices increase
          QkTargetEntry *measure = qk_target_entry_new_measure();
          for (uint32_t i = 0; i< qk_target_num_qubits(target); i++) {
              uint32_t q[1] = {i};
              qk_target_entry_add_property(measure, q, 1, 1e-6 * (i + 1), 1e-3 * (i + 1));
          }
          QkExitCode result_measure = qk_target_add_instruction(target, measure);
          return 0;
      }
