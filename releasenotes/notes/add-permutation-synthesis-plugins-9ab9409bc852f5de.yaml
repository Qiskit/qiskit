---
features:
  - |
    Added several high-level-synthesis plugins for synthesizing permutations.
    The ``BasicSynthesisPermutation`` plugin applies to fully-connected
    architectures and is based on sorting. This is the previously used
    algorithm for constructing quantum circuits for permutations.
    The ``ACGSynthesisPermutation`` plugin also applies to fully-connected
    architectures but is based on the Alon, Chung, Graham method. It synthesizes
    any permutation in depth 2 (measured in terms of SWAPs).
    The ``KMSSynthesisPermutation`` plugin applies to linear nearest-neighbor
    architectures and corresponds to the recently added Kutin, Moulton, Smithline
    method.

    For example::

        from qiskit.circuit.library import Permutation
        from qiskit.circuit import QuantumCircuit

        # Create a permutation and add it to a quantum circuit
        perm = Permutation(8, [4, 6, 3, 7, 1, 2, 0, 5])
        qc = QuantumCircuit(8)
        qc.append(perm, range(8))

        # Print available plugin names for synthesizing permutations
        # Returns ['acg', 'basic', 'default', 'kms']
        print(HighLevelSynthesisPluginManager().method_names("permutation"))

        # Default plugin for permutations
        # Returns a quantum circuit with size 6 and depth 3
        qct = PassManager(HighLevelSynthesis()).run(qc)
        print(f"Default: {qct.size() = }, {qct.depth() = }")

        # KMSSynthesisPermutation plugin for permutations
        # Returns a quantum circuit with size 18 and depth 6
        # but adhering to the linear nearest-neighbor architecture.
        qct = PassManager(HighLevelSynthesis(HLSConfig(permutation=[("kms", {})]))).run(qc)
        print(f"kms: {qct.size() = }, {qct.depth() = }")

        # BasicSynthesisPermutation plugin for permutations
        # Returns a quantum circuit with size 6 and depth 3
        qct = PassManager(HighLevelSynthesis(HLSConfig(permutation=[("basic", {})]))).run(qc)
        print(f"basic: {qct.size() = }, {qct.depth() = }")

        # ACGSynthesisPermutation plugin for permutations
        # Returns a quantum circuit with size 6 and depth 2
        qct = PassManager(HighLevelSynthesis(HLSConfig(permutation=[("acg", {})]))).run(qc)
        print(f"acg: {qct.size() = }, {qct.depth() = }")

upgrade:
  - |
    The :class:`~qiskit.circuit.library.Permutation` is now of type
    :class:`~qiskit.circuit.Gate` and not :class:`qiskit.circuit.QuantumCircuit`.
    This change should be completely transparent to all users. However, it
    avoids synthesizing a permutation circuit when the ``Permutation`` gate
    is declared, delaying the actual synthesis to transpiler. It also allows
    to easily choose between several different algorithms for synthesizing permutations,
    which are available as high-level-synthesis permutation plugins.

    The :class:`~qiskit.circuit.library.Permutation` has a new method
    ``__array__`` that returns a unitary matrix for a permutation, in particular
    allowing to create unitary matrices from circuits containing
    :class:`~qiskit.circuit.library.Permutation` gates.
