---
features:
  - |
    Added a new method, :meth:`~.SparsePauliOp.apply_layout`,
    to the :class:~.SparsePauliOp` class. This method is used to take
    a :class:`~.TranspileLayout` observable for a given input circuit and permute
    it based on the layout from the transpiler. This enables working with
    the :class:`~.BaseEstimator` implementations and local transpilation more
    easily. For example::

        from qiskit.circuit.library import RealAmplitudes
        from qiskit.quantum_info import SparsePauliOp
        from qiskit.primitives import BackendEstimator
        from qiskit.compiler import transpile
        from qiskit.providers.fake_provider import FakeNairobiV2

        psi = RealAmplitudes(num_qubits=2, reps=2)
        H1 = SparsePauliOp.from_list([("II", 1), ("IZ", 2), ("XI", 3)])
        backend = FakeNairobiV2()
        estimator = BackendEstimator(backend=backend, skip_transpilation=True)

        thetas = [0, 1, 1, 2, 3, 5]
        transpiled_psi = transpile(psi, backend, optimization_level=3)
        permuted_op = H1.apply_layout(transpiled_psi.layout)
        res = estimator.run(transpiled_psi, permuted_op, thetas)

    where you locally transpile the input circuit before passing it to
    :class:`~.BaseEstimator.run`, the transpiled circuit will be expanded from
    2 qubits to 7 qubits and the qubits will be permuted as part of
    transpilation. Using :meth:`~.SparsePauliOp.apply_layout`
    transforms ``H1`` which was constructed assuming the original untranspiled
    circuit to reflect the transformations :func:`~.transpile` performed on
    the circuit.
