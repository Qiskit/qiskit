---
features_transpiler:
  - |
    Added support for a :class:`.Target` to specify angle bounds on instructions. Prior to this
    release a :class:`.Target` could specify that an operation that took a parameter either would
    allow any valid value or a specific value. For example, if ``RZGate(Parameter("theta"))`` were
    added to the target that would indicate an :class:`.RZGate` with any value for theta were
    allowed. While if ``RZGate(math.pi)`` were added to the target that would indicate
    :class:`.RZGate` that only :math:`\pi` is the only allowed value on the target. This new feature
    enables restricting the allowed angles to be any ``float`` value between a
    an inclusive bound. For example, you can add ``RZGate(math.pi)`` to a :class:`.Target` and restrict
    the angle value between the values 0 and :math:`2\pi`.

    There are several methods available for working with the angle bouds on the target. The first is
    :meth:`.Target.add_angle_bound` which is used to add an angle bound to an instruction in the
    :class:`.Target`. To add an angle bound you must specify a callback function that will take
    arbitrary ``float`` values representing a gate angles from the circuit and that will return a
    :class:`.DAGCircuit` that represents an equivalent circuit for the gate with that angle but
    respecting the angle bounds. For example::

        target = Target(num_qubits=1)
        target.add_instruction(RZGate(Parameter("theta")))

        def callback(angles: float) -> DAGCircuit:
            angle = angles[0]
            dag = DAGCircuit()
            dag.add_qubits([Qubit()])
            if angle > 0:
                divisor = math.pi
            else:
                divisor = -math.pi
            gate_counts = int(angles[0] // divisor)
            rem = angles[0] % divisor
            for _ in range(gate_counts):
                dag.apply_operation_back(RZGate(math.pi), [dag.qubits[0]], check=True)
            dag.apply_operation_back(rem, [dag.qubits[0]], check=True)

        target.add_bound("rz", [(-math.pi, math.pi)], callback)

    :meth:`.Target.has_angle_bounds` can be used to check whether there are
    any angle bounds set in the target, and :meth:`.Target.gate_has_angle_bound`.

    If you want to apply the angle bounds from a target to any gates in a circuit the
    :class:`.WrapAngles` transpiler pass should be used to do this.
  - |
    Added a new kwarg ``check_angle_bounds`` to the :meth:`.Target.instruction_supported` method.
    When set to ``True`` the method will check if the specified ``parameters``
    also conforms to any angle bounds that may exist for the instruction
    being queried. This argument defaults to ``False`` for both backwards
    compatibility and because the check would add extra overhead to
    the preset pass managers which handle working with angle bounds independently.
  - |
    Added a new transpiler pass :class:`.WrapAngles` which is used to apply
    angle constraints on gates in the :class:`.Target`. If a :class:`.Target` has defined
    angle bounds this pass will analyze all the parameters for the gates in the circuit and
    check that the target. For example, if a target contains a custom gate that has angle bounds
    the pass will decompose that gate into a gate which conforms to the bounds:

    .. plot::
       :include-source:

       from qiskit.circuit import Gate, Parameter, QuantumCircuit
       from qiskit.transpiler import Target
       from qiskit.transpiler.passes import WrapAngles

       class MyCustomGate(Gate):

           def __init__(self, angle):
               super().__init__("my_custom", 1, [angle])

       param = Parameter("a")
       circuit = QuantumCircuit(1)
       circuit.append(MyCustomGate(6.0), [0])
       target = Target(num_qubits=1)
       target.add_instruction(MyCustomGate(param))

       def callback(angles):
           angle = angles[0]
           if angle > 0:
               number_of_gates = angle / 0.5
           else:
               number_of_gates = (6.28 - angle) / 0.5
           dag = DAGCircuit()
           dag.add_qubits([Qubit()])
           for _ in range(int(number_of_gates)):
               dag.apply_operation_back(MyCustomGate(0.5), [dag.qubits[0]])
           return dag

       target.add_angle_bound("my_custom", [(0, 0.5)], callback)
       wrap_pass = WrapAngles(target)
       res = wrap_pass(circuit)
       res.draw('mpl')
