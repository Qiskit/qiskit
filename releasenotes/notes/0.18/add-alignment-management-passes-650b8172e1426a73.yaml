---
features:

  - |
    Added two new passes :class:`~qiskit.transpiler.passes.AlignMeasures` and
    :class:`~qiskit.transpiler.passes.ValidatePulseGates` to the
    :mod:`qiskit.transpiler.passes` module. These passes are a harware aware
    optimization and validation routine that is used to manage alignment
    restrictions on time allocation of instructions for a backend.

    If a backend has a restriction on the alignment of
    :class:`~qiskit.circuit.Measure` instructions (in terms of quantization in time), the
    :class:`~qiskit.transpiler.passes.AlignMeasures` pass is used to adjust
    delays in a scheduled circuit to ensure that the
    :class:`~qiskit.circuit.Measure` instructions in the circuit are aligned
    give the constraints of the backend. The
    :class:`~qiskit.transpiler.passes.ValidatePulseGates` pass is used to
    check if any custom pulse gates (gates that have a custom pulse definition
    in the :attr:`~qiskit.circuit.QuantumCircuit.calibrations` attribute of
    a :class:`~qiskit.circuit.QuantumCircuit` object) will check the pulse
    definitions are valid given an alignment constraint for the target
    backend.

    In the built-in :mod:`~qiskit.transpiler.preset_passmangers` used by the
    :func:`~qiskit.compiler.transpile` function, these passes get automatically
    triggered if the alignment constraint, either via the dedicated
    ``alignment`` kwarg on :func:`~qiskit.compiler.transpiler` or as an
    ``alignment`` attribute in the
    :class:`~qiskit.providers.models.BackendConfiguration` object of the
    backend being targetted, is set to > 1.

    The backends from IBM Quantum Services (accessible via the
    `qiskit-ibmq-provider <https://pypi.org/project/qiskit-ibmq-provider/>`__
    package) will provide the alignment information in the near future.
     
     For example:

    .. jupyter-execute::

      from qiskit import circuit, transpile
      from qiskit.test.mock import FakeArmonk

      backend = FakeArmonk()

      qc = circuit.QuantumCircuit(1, 1)
      qc.x(0)
      qc.delay(110, 0, unit="dt")
      qc.measure(0, 0)
      qc.draw()

    .. jupyter-execute::

      qct = transpile(qc, backend, alignment=16)
      qct.draw()
